#!/usr/bin/env perl
use 5.12.0;
use warnings;

use utf8;
binmode *STDOUT, ':encoding(utf-8)';

use DBI;
use File::HomeDir ();
use Getopt::Long::Descriptive;
use JSON 2 ();
use LWP::UserAgent;
use OAuth::Lite2;
use OAuth::Lite2::Client::WebServer;
use Path::Tiny;

my ($opt, $usage) = describe_options(
  "%c %o",
  [ 'type=s', "what type of playlists to check", { default => 'discover' } ],
);

my $JSON = JSON->new;

my $ROOT = path( File::HomeDir->my_home )->child(".spotrack");
die "no config root $ROOT\n" unless -d $ROOT;

my $db_path = $ROOT->child("spotrack.sqlite");
die "no $db_path\n" unless -e $db_path;

my $config = $JSON->decode( $ROOT->child("oauth.json")->slurp );

my $id      = $config->{id};
my $secret  = $config->{secret};
my $refresh = $config->{refresh};

my $client = OAuth::Lite2::Client::WebServer->new(
  id               => $id,
  secret           => $secret,
  authorize_uri    => q{https://accounts.spotify.com/authorize},
  access_token_uri => q{https://accounts.spotify.com/api/token},
);

my $token_obj = $client->refresh_access_token(refresh_token => $refresh);
my $token = $token_obj->access_token;

my $dbh = DBI->connect(
  "dbi:SQLite:dbname=$db_path",
  undef, undef,
  { sqlite_unicode => 1 }
) or die "can't open db: $DBI::errstr\n";

my $ua = LWP::UserAgent->new(keep_alive => 1);

sub get_tracks {
  my ($user_id, $playlist_id) = @_;
  my $uri = "https://api.spotify.com/v1/users/$user_id/playlists/$playlist_id";
  my $res = $ua->get($uri, 'Authorization' => "Bearer $token");

  unless ($res->is_success) {
    warn "failed to get myself from Spotify: " . $res->status_line . "\n";
    return;
  }

  my $playlist = $JSON->decode($res->decoded_content);
  my $snapshot_id = $playlist->{snapshot_id};

  my ($snapshot_row_id) = $dbh->selectrow_array(
    "SELECT id FROM playlist_snapshots
    WHERE playlist_snapshot_id = ? AND playlist_id = ?",
    { Slice => {} },
    $snapshot_id,
    $playlist_id,
  );

  my @tracks;
  if ($snapshot_row_id) {
    # we have a snapshot!
    my $tracks_ref = $dbh->selectall_arrayref(
      "SELECT * FROM playlist_snapshot_tracks
      WHERE snapshot_id = ?",
      { Slice => {} },
      $snapshot_row_id,
    );

    @tracks = @$tracks_ref;
  } else {
    say "saving tracks for playlist snapshot $snapshot_id";

    die "can't start transaction: " . $dbh->errstr . "\n"
      unless $dbh->begin_work;

    $dbh->do(
      "INSERT INTO playlist_snapshots
        (playlist_snapshot_id, playlist_id, snapshot_time)
      VALUES (?, ?, ?)",
      undef,
      $snapshot_id, $playlist_id, $playlist->{tracks}{items}[0]{added_at},
    );

    my $row_id = $dbh->sqlite_last_insert_rowid;

    my $sth = $dbh->prepare(
      "INSERT INTO playlist_snapshot_tracks
        (snapshot_id, position, track_id, artist, title)
      VALUES (?, ?, ?, ?, ?)",
    );

    my $position = 1;
    for my $item (@{ $playlist->{tracks}{items} }) {
      my $track = $item->{track};

      next if $track->{is_local}; # Should never happen, right?

      my $artists = join q{; }, map {; $_->{name} } @{ $track->{artists} };

      my $row = {
        snapshot_id => $row_id,
        position    => $position++,
        track_id    => $track->{id},
        artist      => $artists,
        title       => $track->{name},
      };

      push @tracks, $row;

      $sth->execute($row->@{qw( snapshot_id position track_id artist title )});
    }

    die "can't commit transaction: " . $dbh->errstr . "\n"
      unless $dbh->commit;
  }

  return { map {; $_->{track_id} => $_ } @tracks };
}

sub compare_playlists {
  my $type = $opt->type;

  my $playlists = $dbh->selectall_arrayref(
    "SELECT id, generator, type, human FROM playlists WHERE type = ?",
    { Slice => {} },
    $type,
  );

  die sprintf "no playlists of type %s\n", $type unless @$playlists;

  my %tracks_for = map {;
    "$_->{human}/$_->{type}" => get_tracks($_->{generator}, $_->{id})
  } @$playlists;

  my %on;
  my %track_label;
  for my $plkey (keys %tracks_for) {
    my $pl = $tracks_for{$plkey};

    for my $t (values %$pl) {
      $track_label{ $t->{track_id } } //= "$t->{title} ($t->{artist})";
      push $on{$t->{track_id}}->@*, $plkey;
    }
  }

  my @duped = grep {; $on{$_}->@* > 1 } keys %on;

  for my $tid (sort { $track_label{$a} cmp $track_label{$b} } @duped) {
    print "$track_label{$tid}\n";
    print "  * $_\n" for sort $on{$tid}->@*;
  }
}

compare_playlists($opt->type);

__END__
CREATE TABLE playlists (
  id text PRIMARY KEY,
  generator text NOT NULL,
  type text NOT NULL,
  human text NOT NULL
);

CREATE TABLE playlist_snapshots (
  id integer PRIMARY KEY,
  playlist_snapshot_id text NOT NULL,
  playlist_id text NOT NULL,
  snapshot_time text NOT NULL
);

CREATE TABLE playlist_snapshot_tracks (
  snapshot_id integer NOT NULL,
  position integer NOT NULL,
  track_id text NOT NULL,
  artist text NOT NULL,
  title text NOT NULL
);
