#!/usr/bin/env perl
use 5.12.0;
use warnings;

use experimental qw( postderef signatures );

use utf8;
# binmode *STDOUT, ':encoding(utf-8)';

use DBI;
use DateTime;
use Getopt::Long::Descriptive;
use JSON 2 ();
use LWP::UserAgent;
use Spudge;
use Try::Tiny;

my ($opt, $usage) = describe_options(
  "%c %o",
  [ 'for=s', "whose top tracks are you getting? defaults to \$USER",
    { default => $ENV{USER} } ],
);

my $JSON = JSON->new;

my $ROOT  = Spudge->root_dir;
my $token = Spudge->get_access_token;

my ($human_id) = Spudge->dbi_connector->dbh->selectrow_array(
  q{SELECT id FROM humans WHERE name = ?},
  undef,
  $opt->for,
);

die "don't know user " . $opt->for . "\n" unless $human_id;

my $ua = LWP::UserAgent->new(keep_alive => 1);

my $now    = DateTime->now(time_zone => 'UTC');
my $yyyymm = $now->format_cldr('YYYYMM');
my $generated_at = $now->iso8601 . 'Z';

sub get_snapshot ($dbh, $time_range) {
  return $dbh->selectrow_hashref(
    q{
      SELECT *
      FROM top_tracks_snapshots
      WHERE human_id = ? AND time_range = ? AND yyyymm = ?
    },
    undef,
    $human_id,
    $time_range,
    $yyyymm,
  );
}


RANGE: for my $time_range (qw( long_term medium_term short_term )) {
  try {
    Spudge->txn(sub {
      my $dbh = $_;

      if (get_snapshot($dbh, $time_range)) {
        warn "Already have top tracks for $yyyymm/$time_range\n";
        return;
      }

      my $prev_snapshot_id = $dbh->selectrow_hashref(
        q{SELECT *
        FROM top_tracks_snapshots
        WHERE human_id = ?
        ORDER BY yyyymm DESC
        LIMIT 1},
        undef,
        $human_id,
      );

      my %last_track_data;
      if ($prev_snapshot_id) {
        my $last_snapshot_tracks = $dbh->selectrow_hashref(
          q{SELECT * FROM top_tracks_snapshot_tracks WHERE snapshot_id = ?},
          undef,
          $prev_snapshot_id,
        );

        %last_track_data = %{ $last_snapshot_tracks // {} };
      }

      my $uri = "https://api.spotify.com/v1/me/top/tracks?limit=40&time_range=$time_range";
      my $res = $ua->get($uri, 'Authorization' => "Bearer $token");

      unless ($res->is_success) {
        warn "failed to get myself from Spotify: " . $res->status_line . "\n";
        return;
      }

      my $playlist = $JSON->decode($res->decoded_content);

      unless ($playlist->{items}->@*) {
        warn "no new items to record\n";
        return;
      }

      $dbh->do(
        q{
          INSERT INTO top_tracks_snapshots
          (human_id, yyyymm, time_range, generated_at)
          VALUES (?, ?, ?, ?)
        },
        undef,
        $human_id,
        $yyyymm,
        $time_range,
        $generated_at,
      );

      my $snapshot_id = $dbh->sqlite_last_insert_rowid;

      my $sth = $dbh->prepare(
        q{
          INSERT INTO top_tracks_snapshot_tracks
          (snapshot_id, position, track_id, artist, title, run_count, previous_position)
          VALUES (?, ?, ?, ?, ?, ?, ?)
        },
      );

      for my $i (keys $playlist->{items}->@*) {
        my $track = $playlist->{items}->[$i];
        my $title = $track->{name};
        my $by    = join q{; }, map {; $_->{name} } $track->{artists}->@*;
        say "$title by $by";

        my $last_time = $last_track_data{ $track->{id} } // { run_count => 0 };

        $sth->execute(
          $snapshot_id,
          $i+1,
          $track->{id},
          $by,
          $title,
          $last_time->{run_count} + 1,
          $last_time->{position},
        );
      }
    });
  } catch {
    die $_;
  }
}

