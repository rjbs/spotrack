#!/usr/bin/env perl
use 5.12.0;
use warnings;

use experimental 'postderef';

use utf8;
# binmode *STDOUT, ':encoding(utf-8)';

use DBI;
use Getopt::Long::Descriptive;
use JSON 2 ();
use LWP::UserAgent;
use Spudge;

my ($opt, $usage) = describe_options(
  "%c %o",
  [ 'for=s', "whose history are you getting? defaults to \$USER",
    { default => $ENV{USER} } ],
);

my $JSON = JSON->new;

my $ROOT  = Spudge->root_dir;
my $token = Spudge->get_access_token;

my $db_path = $ROOT->child("spotrack.sqlite");

my $dbh = Spudge->dbi_connector->dbh;

my ($human_id) = $dbh->selectrow_array(
  q{SELECT id FROM humans WHERE name = ?},
  undef,
  $opt->for,
);

die "don't know user " . $opt->for . "\n" unless $human_id;

my $ua = LWP::UserAgent->new(keep_alive => 1);

sub get_since {
  my ($after_ms) = @_;
  $after_ms //= 0;

  my $uri = "https://api.spotify.com/v1/me/player/recently-played?limit=50&after=$after_ms";
  my $res = $ua->get($uri, 'Authorization' => "Bearer $token");

  unless ($res->is_success) {
    warn "failed to get myself from Spotify: " . $res->status_line . "\n";
    return;
  }

  my $playlist = $JSON->decode($res->decoded_content);

  unless ($playlist->{items}->@*) {
    warn "no new items to record\n";
    return;
  }

  die "can't start transaction: " . $dbh->errstr . "\n"
    unless $dbh->begin_work;

  my $sth = $dbh->prepare(
    q{
      INSERT INTO complete_play_history
      (human_id, played_at, track_id, artist, album, title, context_uri)
      VALUES (?, ?, ?, ?, ?, ?, ?)
    }
  );

  for my $item ($playlist->{items}->@*) {
    my $track = $item->{track};
    my $title = $track->{name};
    my $by    = join q{; }, map {; $_->{name} } $track->{artists}->@*;
    say "$title by $by";

    $sth->execute(
      $human_id,
      $item->{played_at},
      $track->{id},
      $by,
      q{}, # We need to fetch the track separately to get album name.
      $title,
      $item->{context}{uri},
    );
  }

  $dbh->do(
    q{
      INSERT INTO history_positions (human_id, next_cursor_start_ms)
      VALUES (?, ?)
      ON CONFLICT(human_id) DO UPDATE SET next_cursor_start_ms = ?
    },
    undef,
    $human_id, ($playlist->{cursors}{after}) x 2
  );

  die "can't commit transaction: " . $dbh->errstr . "\n"
    unless $dbh->commit;

  say "NEXT: $playlist->{cursors}{after}";
}

my ($next_cursor_start_ms) = $dbh->selectrow_array(
  q{SELECT next_cursor_start_ms FROM history_positions WHERE human_id = ?},
  undef,
  $human_id,
);

get_since($next_cursor_start_ms);
